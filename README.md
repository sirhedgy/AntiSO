This is a library that is supposed to use new C#/.Net [Code Generators](https://devblogs.microsoft.com/dotnet/introducing-c-source-generators/) feature to automatically transform recursive methods into equivalent ones that use an explicit on-heap Stack to run an thus avoid stack overflow (hence the AntiSO name).

Currently it is in an early proof of concept stage with a very limited with support.

# General idea

The main idea of the code generation is to use `IEnumerator<T>`s generated by the C# compiler from `yield return` to simulate calls on an explicit stack. When an `IEnumerator` is generated from `yield return`, the compiler has to simulate the local state of the generator function thus essentially providing a cheap way for us to create one stack frame for an arbitrary function. All we need now to run a recursion is to put those frames onto an explicit on-heap stack. 

For example a recursive code for [Fibonacci numbers](https://en.wikipedia.org/wiki/Fibonacci_number)

```C#   
static long Fib(int n)
{
    if(n <= 1)
        return 1;
    return Fib(n-1) + Fib(n-2);
}
```
         
Can be transformed into something like this      

```C#   
// here IEnumerator<int> represents the fact that Fib takes single int argument
IEnumerator<int> FibNoRec(int n)
{
    if(n <= 1) {
        StoreReturnValue(1);
        yield break;
    }
    
    // var f1 = Fib(n-1);
    yield return (n-1);
    // here Fib(n-1) will be executed by the runner
    var f1 = GetLastReturnValue();
    // var f2 = Fib(n-2);
    yield return (n-2);
    // here Fib(n-2) will be executed by the runner
    var f2 = GetLastReturnValue();
    StoreReturnValue(f1 + f2); 
}
```

And so some "runner" class that implements `StoreReturnValue`/`GetReturnValue` and manages the stack could run this code:

```C#   
class FibRunner
{
    // we need just one field behind this pair of methods
    private long _lastReturnValue;
    private long GetLastReturnValue() { return _lastReturnValue; }    
    private void StoreReturnValue(long returnValue) { _lastReturnValue = returnValue;}
      
    private IEnumerator<int> FibNoRec(int n) {...}
    
    public long RunFibRecursion(int n)
    {
        var stack = new Stack<IEnumerator<int>>();
        var curState = FibNoRec(n); // the initial call
        while (true)
        {
            if (curState.MoveNext())
            {
                // We have an inner call
                var innerCall = curState.Current;
                stack.Push(curState);
                curState = FibNoRec(innerCall);
            }
            else
            {
                // We have run out of inner calls and finished the current call
                // so get back to the parent call.
                if (!stack.TryPop(out curState))
                    break;
            }
        }
        return GetLastReturnValue();
    }
}
```

The idea of this library is that all this code can theoretically be automatically generated from the original recursive version.


# Usage

The library itself consist of 2 assemblies:

- `AntiSO.Shared` that contains the `GenerateSafeRecursionAttribute` and some other helper code and is required at runtime
- `AntiSO.CodeGen` that contains the `ISourceGenerator` and is required only at the compile time (beware that it depends on the `AntiSO.Shared` so you need both during the compile time)

So you add something like this to your .csproj file: 

```XML
    <PropertyGroup>
        <AntiSOLibDir>$(ProjectDir)\Lib\AntiSO\</AntiSOLibDir>
    </PropertyGroup>
    <ItemGroup>
        <!--    reference the AntiSO.Shared assembly -->
        <Reference Include="$(AntiSOLibDir)\AntiSO.Shared.dll" />

        <!--    Add to Analyzer both AntiSO.Shared and AntiSO.CodeGen assemblies -->
        <Analyzer Include="$(AntiSOLibDir)\AntiSO.CodeGen.dll;$(AntiSOLibDir)\AntiSO.Shared.dll;" />
    </ItemGroup>
```

You also might want to add something like this to your .csproj file to see the generated code: 

```XML
    <EmitCompilerGeneratedFiles>true</EmitCompilerGeneratedFiles>
    <CompilerGeneratedFilesOutputPath>$(BaseIntermediateOutputPath)\GeneratedFiles</CompilerGeneratedFilesOutputPath>
```


In your code you turn on the code generation by using the `GenerateSafeRecursionAttribute` from the `AntiSO` namespace from the `AntiSO.Shared` assembly:

```C#   
public static partial class Fibonacci {
    // Nobody will actually call this method, it is only a template
    // Everybody will call the generated stack-safe "Fib" method instead
    [GenerateSafeRecursion(AccessLevel = AccessLevel.Public, GeneratedMethodName = "Fib", ExtensionMethod = ExtensionMethod.Extenstion)]
    private static long FibRec(int n)
    {
        if (n <= 1)
            return 1;
        var f1 = Fib1Rec(n - 1);
        var f2 = Fib1Rec(n - 2);
        return f1 + f2;
    }
}
```

This will generate an additional code for the `Fibonacci` partial class with the following signature for the entry point:

```C#   
public static long Fib(this int n)
```

## `GenerateSafeRecursionAttribute` configuration

The code generation is controlled by the `GenerateSafeRecursionAttribute`. All its properties are optional. Their meaning and defaults are:

- If `GeneratedMethodName` is missing or `null`, the default name will be `{OriginalMethodName}_GenSafeRec` where `_GenSafeRec` is a fixed suffix also known as the `GenerateSafeRecursionAttribute.DefaultNameSuffix`

- If `AccessLevel` is missing then the new method will have the same access level as the original one

- `ExtensionMethod` controls whether the new generated method is an extension method or a usual one. By default the new method is the same as the original one.

- `MutualRecursionId` is used to mark a group of methods that are a part of the same mutual recursion. It should be `null` for usual cases. See an [example](#mutual-recursion-example) below for more details.

- `ExposeAsEntryPoint` only makes sense for mutual recursion. It allows to expose only some of the recursive methods in the group and hide the others. See an [example](#mutual-recursion-example) below for more details.


Expected usages of `GenerateSafeRecursionAttribute` follow one of the two typical scenarios:

- If your public interface consist of some "proxy" method that checks the input parameters and forwards the "small" calls (according to some heuristic of what will 100% not fail with stack overflow) to the original (faster) implementation and the "big" calls to the generated one, then your method decorated with `GenerateSafeRecursionAttribute` is probably `private`, and you leave all attribute properties to their default values (i.e. copy everything as is), and just call the method decorated with `_GenSafeRec` suffix in your "big" branch. Another advantage of a proxy method is that while IDE has no support for the code generators, it limits the number of the IDE-confusing places where the generated function is being called. 

- If you want to use the generated code only, you make your original method `private` and decorate it with some suffix, and use `GenerateSafeRecursionAttribute` as in the `Fibonacci` example above: you specify nice `GeneratedMethodName`, your required `AccessLevel` (typically `Public`), and optionally turn on `ExtensionMethod`.


### Mutual recursion example

Mutual recursion is supported but it requires you to explicitly mark all the methods that call each other with the `GenerateSafeRecursionAttribute`. To show that the methods are a part of the same mutual recursion you use the `MutualRecursionId` property with the same string constant. Note that currently all such methods must be in the same class and in the same file. Also generics support is very limited. Essentially all the mutual recursive methods should have exactly the same set of generic parameters in exactly the same order with exactly the same `where` constraints.

The following mutually recursive code

```C#   
public partial class MutualRecursion
{
    private const string OddEvenMutualRecursionId = "IsOddEven";


    [GenerateSafeRecursion(MutualRecursionId = OddEvenMutualRecursionId, GeneratedMethodName= "IsOdd", AccessLevel = AccessLevel.Public, ExposeAsEntryPoint = true)]
    private static bool IsOddRec(int n)
    {
        if (n < 0)
            return IsOddRec(-n);
        var isEven = IsEvenRec(n);
        return !isEven;
    }

    [GenerateSafeRecursion(MutualRecursionId = OddEvenMutualRecursionId, ExposeAsEntryPoint = false)]
    private static bool IsEvenRec(int n)
    {
        if (n == 0)
            return true;
        return IsOddRec(n - 1);
    }
}
```

will generate an additional code for the `MutualRecursion` partial class with the following signature for the entry point:

```C#
public static bool IsOdd(int n)   
```

Note that no entry point will be generated for `IsEvenRec` method because `ExposeAsEntryPoint` is configured to be `false`.

### Sample Project
You can find trivial sample projects (library + app) in the [SampleProject](SampleProject) folder.


## Supported features/limitations

One fundamental limitation is that Code Generators can only generate new code and can't modify any of the existing code. It means among other things that the original recursive function will also stick forever in your compiled code.

Current implementation is very limited and only supports certain usages:

- All recursive calls must be a part of direct assignments to some named variables or direct returns.  
   
```C#   
[GenerateSafeRecursionAttribute]
int Foo(int p1, int p2) {
    if ((p1 <= 0) || (p2 <= 0))
            return 0;
    int good1;
    // supported:
    good1 = Foo(p1 - 1, p2);    // direct assignment
    var good2 = Foo(good1, p1); // var initialization, also note that the dependency between good2 and good1 is not an issue
    int notRelated1 = 1, good3 = Foo(p1 - 1, p2), notRelated2 = 2; // var initialization among several vars
    return Foo(p1-1, p2);   // direct return
    
    // the following versions are not supported yet:
    var bad1 = Foo(p1 - 1, p2) + 1; //arithemtic expression
    var bad2 = Math.Max(Foo(p1 - 1, p2), p1); // nested call
    int bad3;
    while (0 != (bad3 = Foo(p1-1, p2)) // nested assignment
    for(var bad4 = Foo(p1-1, p2); bad4 < 100; bad4++) // nested assignment
    if (Foo(p1 - 1, p2) < 0) // nested call
    throw Foo(p1-1, p2);    // throw recursive call results (who would ever need that?)
    // probably many other ways to place a recursive call are not supported
} 
```

- The function itself should be a top-level method (no local functions) of a top level class and the class itself should be defined as `partial`.

- The class containing the function should be put directly into a single `namespace` declaration i.e. no nested `namespace` declarations  

- All `using`s should be at the top level, no `using`s inside a namespace. 

- Since the generated code works by rewriting recursive calls into `yield return`s, the original method can't use `yield return` itself.

- Throwing and catching exceptions inside the recursion is not really supported yet. Usually the generated code will not compile at all. If it does compile, it might work somehow but might produce unexpected results.

- Multithreading and synchronization/locks are not supported. 

- Mutual recursion support is only half-automatic and requires all the methods to be in the same class. Also generics support in a mutual recursion is very limited.


# TODO List

- Support methods with `out` parameters
- Write some proper tests
- Support recursive calls inside at least simple arithmetic expressions
- Support recursive calls in variable declaration inside `for` and `foreach` (what is a good example of `foreach`?)
- Handling of exceptions and try/finally will always be limited but can it be improved and extended?
- Similarly handling of threads and locks will always be limited but can it be improved and extended?
- Long term: Support all possible location of recursive calls
- Maybe support for memoization in case of pure functions?
